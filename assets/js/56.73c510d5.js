(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{334:function(t,e,a){"use strict";a.r(e);var s=a(10),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git基本原理及常用命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git基本原理及常用命令"}},[t._v("#")]),t._v(" Git基本原理及常用命令")]),t._v(" "),e("blockquote",[e("p",[t._v("Git是目前世界上最先进的分布式版本控制系统")])]),t._v(" "),e("p",[t._v("本篇文章将重点讲解大多数人忽略或者不清楚的点，注意: 这不是一篇大而全的git使用教程, 只会重点讲解一些关键知识点，如果你需要更全的git教程，你应该去查看"),e("a",{attrs:{href:"https://git-scm.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"git-add-commit-与-git-commit-am-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-add-commit-与-git-commit-am-的区别"}},[t._v("#")]),t._v(" git add + commit 与 git commit -am 的区别")]),t._v(" "),e("p",[t._v("大多数人喜欢用后面的一种方式来添加提交本地代码到本地仓库中，但后一种与前一种方式并不是完全相等的。"),e("br"),t._v("\n熟悉Git的同学知道，我们在项目中新建一个新文件后，它的状态是 "),e("code",[t._v("untracked")]),t._v(" 的，当我们使用 "),e("code",[t._v("git add .")]),t._v(" 将其添加到暂存区时，它的状态就会变为 "),e("code",[t._v("tracked")]),t._v(" ，即可追踪的。当我们用 "),e("code",[t._v("git commit")]),t._v(" 的时候会将暂存区的文件提交到本地仓库生成一个commit记录。"),e("br"),t._v(" "),e("code",[t._v("git commit -am")]),t._v(" 只会将 "),e("code",[t._v("tracked")]),t._v(" 状态的文件commit到本地仓库，意思是如果你有新的文件产生，并且之前没有用 "),e("code",[t._v("git add")]),t._v(" 将其状态变为 "),e("code",[t._v("tracked")]),t._v(" ，使用 "),e("code",[t._v("git commit -am")]),t._v(" 并不能将该文件commit到本地仓库，容易造成文件的丢失。")]),t._v(" "),e("h2",{attrs:{id:"常用命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" reset "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--hard")]),t._v(" ^HEAD "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 版本回退")]),t._v("\n$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout -- "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("file"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 撤销修改")]),t._v("\n$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" stash "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 暂存修改")]),t._v("\n$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" stash apply "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 恢复修改")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h2",{attrs:{id:"多人合作开发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多人合作开发"}},[t._v("#")]),t._v(" 多人合作开发")]),t._v(" "),e("p",[t._v("如果要开发多人合作项目，我们建议将master分支设置为"),e("a",{attrs:{href:"https://help.github.com/en/articles/configuring-protected-branches",target:"_blank",rel:"noopener noreferrer"}},[t._v("protected"),e("OutboundLink")],1),t._v("分支，使得不允许直接在master上提交代码，只能通过PR的形式来合并。如何向项目提交PR请参考"),e("a",{attrs:{href:"https://www.zhihu.com/question/21682976/answer/79489643",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub 的 Pull Request 是指什么意思？"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"使用git-flow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用git-flow"}},[t._v("#")]),t._v(" 使用git-flow")]),t._v(" "),e("p",[t._v("使用"),e("a",{attrs:{href:"https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow",target:"_blank",rel:"noopener noreferrer"}},[t._v("git-flow"),e("OutboundLink")],1),t._v("这个工具可以帮助我们更好的控制我们的工作流程")]),t._v(" "),e("h2",{attrs:{id:"commit-message-规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commit-message-规范"}},[t._v("#")]),t._v(" commit message 规范")]),t._v(" "),e("p",[t._v("commit message是必须要遵循一定的规范的，随意的commit message只会让人感受到不专业。这里我们参考"),e("a",{attrs:{href:"https://gist.github.com/stephenparish/9941e89d80e2bc58a153",target:"_blank",rel:"noopener noreferrer"}},[t._v("AngularJS commit message conventions"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("为了确保每一次代码提交的规范性，本项目使用Angular 的 Commit 规范：")])]),t._v(" "),e("ul",[e("li",[t._v("feat：开发了一个新功能")]),t._v(" "),e("li",[t._v("fix：修复了一个Bug")]),t._v(" "),e("li",[t._v("docs：更新了文档（比如改了 Readme）")]),t._v(" "),e("li",[t._v("style：代码的样式美化，不涉及到功能修改（比如改了缩进）")]),t._v(" "),e("li",[t._v("refactor：一些代码结构上优化，既不是新特性也不是修 Bug（比如函数改个名字）")]),t._v(" "),e("li",[t._v("perf：优化了性能的代码改动")]),t._v(" "),e("li",[t._v("test：新增或者修改已有的测试代码")]),t._v(" "),e("li",[t._v("build：构建流程、外部依赖变更，比如升级 npm 包、修改 webpack 配置等")]),t._v(" "),e("li",[t._v("ci：更改CI配置文件和脚本（如Travis）")]),t._v(" "),e("li",[t._v("chore：跟仓库主要业务无关的构建/工程依赖/工具等功能改动（比如新增一个文档生成工具）")]),t._v(" "),e("li",[t._v("revert：恢复上一次提交")])]),t._v(" "),e("h2",{attrs:{id:"使用git-rebase-来合并你的commit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用git-rebase-来合并你的commit"}},[t._v("#")]),t._v(" 使用git rebase 来合并你的commit")]),t._v(" "),e("p",[t._v("大部分人在实际开发过程中，都会建立自己的分支开发，这是大部分团队都能做到的，但是我们在测试问题的时候总是会提交一些无用的commit去远程的repo，自己的分支还好，但是最后把自己的分支合并到master上的时候如果还带上这些commit就十分不雅观了，当然github的PR功能已经给我们合并PR的时候提供了多种选项，其中就包括rebase。但是这里还是要介绍一个很多人不常用的命令，git rebase，也就是变基，git rebase功能很强大，也很容易一不小心弄不好就把你的整个commit或者git历史弄乱，所以这里我们不写如何用它来变基，只说如何用它来合并自己的commit。"),e("a",{attrs:{href:"http://gitbook.liuhui998.com/4_2.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考教程"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("注意事项: 只有个人操作的分支才可以用git rebase，多人一起协作的分支切记不要轻易使用git rebase, 否则很容易造成冲突。")]),t._v(" "),e("p",[t._v("你执行了rebase命令的分支如果和远程仓库的commit history不一样，是没有办法直接push到远程仓库的，因为这时候你本地仓库的commit history已经修改了，和远程的会冲突。")]),t._v(" "),e("p",[t._v("解决方式")]),t._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" push origin dev "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-f")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用--force来强制push，但你要清楚这可能会导致你的一些commit记录的丢失，所以请仅在个人分支进行该操作")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h2",{attrs:{id:"git-merge-与-git-rebase区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-与-git-rebase区别"}},[t._v("#")]),t._v(" git merge 与 git rebase区别")]),t._v(" "),e("ul",[e("li",[t._v("git merge 操作合并分支会让两个分支的每一次提交都按照提交时间（并不是push时间）排序，并且会将两个分支的最新一次commit点进行合并成一个新的commit，最终的分支树呈现非整条线性直线的形式")]),t._v(" "),e("li",[t._v("git rebase操作实际上是将当前执行rebase分支的所有基于原分支提交点之后的commit打散成一个一个的patch，并重新生成一个新的commit hash值，再次基于原分支目前最新的commit点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，rebase完成后，切到基分支进行合并另一个分支时也不会生成一个新的commit点，可以保持整个分支树的完美线性。另外值得一提的是，当我们开发一个功能时，可能会在本地有无数次commit，而你实际上在你的master分支上只想显示每一个功能测试完成后的一次完整提交记录就好了，其他的提交记录并不想将来全部保留在你的master分支上，那么rebase将会是一个好的选择，他可以在rebase时将本地多次的commit合并成一个commit，还可以修改commit的描述等。")])]),t._v(" "),e("h2",{attrs:{id:"git常用命令总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git常用命令总结"}},[t._v("#")]),t._v(" Git常用命令总结")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.processon.com/view/link/613974251efad40d93a47748",target:"_blank",rel:"noopener noreferrer"}},[t._v("个人ProcessOn思维导图分享链接"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);